# -*- coding: utf-8 -*-
"""Model development and training.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hJPzcjIuGqvOIwOJf3mDu69iyE1TBuos
"""

import torch
from torch import nn
import torchvision
from torchvision import transforms
from sklearn.metrics import accuracy_score
from tqdm import tqdm
import matplotlib.pyplot as plt

# Define the CNN models
class Chest_xray_1(nn.Module):
    def __init__(self, input_channels: int, num_classes: int):
        super().__init__()
        self.conv_block_1 = nn.Sequential(
            nn.Conv2d(in_channels=input_channels, out_channels=20, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.Conv2d(in_channels=20, out_channels=20, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=2)
        )
        self.conv_block_2 = nn.Sequential(
            nn.Conv2d(in_channels=20, out_channels=20, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.Conv2d(in_channels=20, out_channels=20, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=2)
        )
        self.dropout = nn.Dropout(0.5)
        self.classifier = nn.Sequential(
            nn.Flatten(),
            nn.Linear(in_features=20 * 16 * 16, out_features=num_classes),
            nn.Sigmoid()
        )

    def forward(self, x):
        x = self.conv_block_1(x)
        x = self.conv_block_2(x)
        x = self.dropout(x)
        x = self.classifier(x)
        return x

class Chest_xray_2(nn.Module):
    def __init__(self, input_channels: int, num_classes: int):
        super().__init__()
        self.conv_block = nn.Sequential(
            nn.Conv2d(in_channels=input_channels, out_channels=32, kernel_size=5, stride=1, padding=2),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=2),
            nn.Conv2d(in_channels=32, out_channels=64, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=2)
        )
        self.fc_block = nn.Sequential(
            nn.Linear(64 * 16 * 16, 256),
            nn.ReLU(),
            nn.Dropout(0.5),
            nn.Linear(256, num_classes),
            nn.Sigmoid()
        )

    def forward(self, x):
        x = self.conv_block(x)
        x = x.view(x.size(0), -1)
        x = self.fc_block(x)
        return x

# Define a function to calculate loss and accuracy
def calculate_loss_and_accuracy(model, dataloader, loss_fn):
    model.eval()
    total_loss = 0.0
    all_preds = []
    all_labels = []

    with torch.no_grad():
        for X, y in dataloader:
            X, y = X.to('cuda'), y.to('cuda')
            y_pred = model(X)
            loss = loss_fn(y_pred, y.float().unsqueeze(1))
            total_loss += loss.item()
            preds = y_pred.round()
            all_preds.extend(preds.cpu().numpy())
            all_labels.extend(y.cpu().numpy())

    avg_loss = total_loss / len(dataloader)
    accuracy = accuracy_score(all_labels, all_preds)
    return avg_loss, accuracy

# Initialize models
torch.manual_seed(42)
model_1 = Chest_xray_1(input_channels=3, num_classes=1).to('cuda')
model_2 = Chest_xray_2(input_channels=3, num_classes=1).to('cuda')

# List of models to train
models_list = [model_1, model_2]
model_names = ["Model_1", "Model_2"]

train_losses = [[] for _ in range(len(models_list))]
val_losses = [[] for _ in range(len(models_list))]
test_losses = [[] for _ in range(len(models_list))]

train_accuracies = [[] for _ in range(len(models_list))]
val_accuracies = [[] for _ in range(len(models_list))]
test_accuracies = [[] for _ in range(len(models_list))]

loss_fn = nn.BCELoss(reduction='mean')
epochs = 5

# Training loop
for model, name, train_losses_model, val_losses_model, test_losses_model, train_accuracies_model, val_accuracies_model, test_accuracies_model in zip(models_list, model_names, train_losses, val_losses, test_losses, train_accuracies, val_accuracies, test_accuracies):
    print(f"\nTraining {name}...\n")
    model = model.to('cuda')
    optimizer = torch.optim.SGD(model.parameters(), lr=0.1)

    for epoch in tqdm(range(1, epochs + 1)):
        print(f'Epoch: {epoch}\n-----')
        model.train()
        total_loss = 0.0
        all_preds = []
        all_labels = []

        for X, y in train_dataloader:
            X, y = X.to('cuda'), y.to('cuda')
            optimizer.zero_grad()
            y_pred = model(X)
            loss = loss_fn(y_pred, y.float().unsqueeze(1))
            loss.backward()
            optimizer.step()
            total_loss += loss.item()
            preds = y_pred.round()
            all_preds.extend(preds.detach().cpu().numpy())
            all_labels.extend(y.detach().cpu().numpy())

        train_loss = total_loss / len(train_dataloader)
        train_losses_model.append(train_loss)
        train_accuracy = accuracy_score(all_labels, all_preds)
        train_accuracies_model.append(train_accuracy)

        val_loss, val_accuracy = calculate_loss_and_accuracy(model, val_dataloader, loss_fn)
        val_losses_model.append(val_loss)
        val_accuracies_model.append(val_accuracy)

        print(f'Train loss: {train_loss:.4f}, Train accuracy: {train_accuracy:.4f}')
        print(f'Validation loss: {val_loss:.4f}, Validation accuracy: {val_accuracy:.4f}')

        test_loss, test_accuracy = calculate_loss_and_accuracy(model, test_dataloader, loss_fn)
        test_losses_model.append(test_loss)
        test_accuracies_model.append(test_accuracy)

        print(f'Test loss: {test_loss:.4f}, Test accuracy: {test_accuracy:.4f}')

# Plot losses and accuracies
for name, train_losses_model, val_losses_model, test_losses_model, train_accuracies_model, val_accuracies_model, test_accuracies_model in zip(model_names, train_losses, val_losses, test_losses, train_accuracies, val_accuracies, test_accuracies):
    min_length = min(len(train_losses_model), len(val_losses_model), len(test_losses_model), len(train_accuracies_model), len(val_accuracies_model), len(test_accuracies_model))
    epochs_range = range(1, min_length + 1)

    plt.figure(figsize=(12, 4))

    plt.subplot(1, 2, 1)
    plt.plot(epochs_range, train_losses_model[:min_length], label='Train Loss')
    plt.plot(epochs_range, val_losses_model[:min_length], label='Validation Loss')
    plt.plot(epochs_range, test_losses_model[:min_length], label='Test Loss')
    plt.title(f'{name} Loss')
    plt.xlabel('Epochs')
    plt.ylabel('Loss')
    plt.legend()

    plt.subplot(1, 2, 2)
    plt.plot(epochs_range, train_accuracies_model[:min_length], label='Train Accuracy')
    plt.plot(epochs_range, val_accuracies_model[:min_length], label='Validation Accuracy')
    plt.plot(epochs_range, test_accuracies_model[:min_length], label='Test Accuracy')
    plt.title(f'{name} Accuracy')
    plt.xlabel('Epochs')
    plt.ylabel('Accuracy')
    plt.legend()

    plt.show()